{"version":3,"sources":["meta.js"],"names":[],"mappings":"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","file":"meta-compiled.js","sourcesContent":["/*istanbul ignore next*/\"use strict\";\n\nvar /*istanbul ignore next*/_assert = require(\"assert\");\n\n/*istanbul ignore next*/\nvar _assert2 = _interopRequireDefault(_assert);\n\nvar /*istanbul ignore next*/_babelTypes = require(\"babel-types\");\n\n/*istanbul ignore next*/\nvar t = _interopRequireWildcard(_babelTypes);\n\n/*istanbul ignore next*/\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar m = require(\"private\").makeAccessor(); /**\n                                            * Copyright (c) 2014, Facebook, Inc.\n                                            * All rights reserved.\n                                            *\n                                            * This source code is licensed under the BSD-style license found in the\n                                            * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n                                            * additional grant of patent rights can be found in the PATENTS file in\n                                            * the same directory.\n                                            */\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    var result = false;\n\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n          child.some(check);\n        } else if (t.isNode(child)) {\n          /*istanbul ignore next*/_assert2.default.strictEqual(result, false);\n          result = predicate(child);\n        }\n      return result;\n    }\n\n    var keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    t.assertNode(node);\n\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n\n  return predicate;\n}\n\nvar opaqueTypes = {\n  FunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nvar sideEffectTypes = {\n  CallExpression: true, // Anything could happen!\n  ForInStatement: true, // Modifies the key variable.\n  UnaryExpression: true, // Think delete.\n  BinaryExpression: true, // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true, // Side-effecting by definition.\n  UpdateExpression: true, // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);"]}