{"version":3,"sources":["rest.js"],"names":[],"mappings":"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","file":"rest-compiled.js","sourcesContent":["/*istanbul ignore next*/\"use strict\";\n\nexports.__esModule = true;\nexports.visitor = undefined;\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar /*istanbul ignore next*/_babelTemplate = require(\"babel-template\");\n\n/*istanbul ignore next*/\nvar _babelTemplate2 = _interopRequireDefault(_babelTemplate);\n\nvar /*istanbul ignore next*/_babelTypes = require(\"babel-types\");\n\n/*istanbul ignore next*/\nvar t = _interopRequireWildcard(_babelTypes);\n\n/*istanbul ignore next*/\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* eslint indent: 0 */\n\nvar buildRest = /*istanbul ignore next*/(0, _babelTemplate2.default)( /*istanbul ignore next*/\"\\n  for (var LEN = ARGUMENTS.length,\\n           ARRAY = Array(ARRAY_LEN),\\n           KEY = START;\\n       KEY < LEN;\\n       KEY++) {\\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\\n  }\\n\");\n\nvar loadRest = /*istanbul ignore next*/(0, _babelTemplate2.default)( /*istanbul ignore next*/\"\\n  ARGUMENTS.length <= INDEX ? undefined : ARGUMENTS[INDEX]\\n\");\n\nvar memberExpressionOptimisationVisitor = { /*istanbul ignore next*/\n  Scope: function Scope(path, state) {\n    // check if this scope has a local binding that will shadow the rest parameter\n    if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      path.skip();\n    }\n  },\n  /*istanbul ignore next*/Flow: function Flow(path) {\n    // don't touch reference in type annotations\n    path.skip();\n  },\n\n\n  \"Function|ClassProperty\": function /*istanbul ignore next*/FunctionClassProperty(path, state) {\n    // Detect whether any reference to rest is contained in nested functions to\n    // determine if deopt is necessary.\n    var oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    path.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n\n    // Skip because optimizing references to rest would refer to the `arguments`\n    // of the nested function.\n    path.skip();\n  },\n\n  /*istanbul ignore next*/ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n    /*istanbul ignore next*/var node = path.node;\n\n    // we can't guarantee the purity of arguments\n\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    // is this a referenced identifier and is it referencing the rest parameter?\n    if (node.name !== state.name) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      /*istanbul ignore next*/var parentPath = path.parentPath;\n\n      // ex: `args[0]`\n      // ex: `args.whatever`\n\n      if (parentPath.isMemberExpression({ object: node })) {\n        var grandparentPath = parentPath.parentPath;\n\n        var argsOptEligible = !state.deopted && !(\n        // ex: `args[0] = \"whatever\"`\n        grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left ||\n\n        // ex: `[args[0]] = [\"whatever\"]`\n        grandparentPath.isLVal() ||\n\n        // ex: `for (rest[0] in this)`\n        // ex: `for (rest[0] of this)`\n        grandparentPath.isForXStatement() ||\n\n        // ex: `++args[0]`\n        // ex: `args[0]--`\n        grandparentPath.isUpdateExpression() ||\n\n        // ex: `delete args[0]`\n        grandparentPath.isUnaryExpression({ operator: \"delete\" }) ||\n\n        // ex: `args[0]()`\n        // ex: `new args[0]()`\n        // ex: `new args[0]`\n        (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);\n\n        if (argsOptEligible) {\n          if (parentPath.node.computed) {\n            // if we know that this member expression is referencing a number then\n            // we can safely optimise it\n            if (parentPath.get(\"property\").isBaseType(\"number\")) {\n              state.candidates.push({ cause: \"indexGetter\", path: path });\n              return;\n            }\n          }\n          // args.length\n          else if (parentPath.node.property.name === \"length\") {\n              state.candidates.push({ cause: \"lengthGetter\", path: path });\n              return;\n            }\n        }\n      }\n\n      // we can only do these optimizations if the rest variable would match\n      // the arguments exactly\n      // optimise single spread args in calls\n      // ex: fn(...args)\n      if (state.offset === 0 && parentPath.isSpreadElement()) {\n        var call = parentPath.parentPath;\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push({ cause: \"argSpread\", path: path });\n          return;\n        }\n      }\n\n      state.references.push(path);\n    }\n  },\n  /*istanbul ignore next*/\n\n  /**\n   * Deopt on use of a binding identifier with the same name as our rest param.\n   *\n   * See https://github.com/babel/babel/issues/2091\n   */\n\n  BindingIdentifier: function BindingIdentifier(_ref, state) {\n    /*istanbul ignore next*/var node = _ref.node;\n\n    if (node.name === state.name) {\n      state.deopted = true;\n    }\n  }\n};\nfunction hasRest(node) {\n  return t.isRestElement(node.params[node.params.length - 1]);\n}\n\nfunction optimiseIndexGetter(path, argsId, offset) {\n  var index = /*istanbul ignore next*/void 0;\n\n  if (t.isNumericLiteral(path.parent.property)) {\n    index = t.numericLiteral(path.parent.property.value + offset);\n  } else {\n    index = t.binaryExpression(\"+\", path.parent.property, t.numericLiteral(offset));\n  }\n\n  path.parentPath.replaceWith(loadRest({\n    ARGUMENTS: argsId,\n    INDEX: index\n  }));\n}\n\nfunction optimiseLengthGetter(path, argsLengthExpression, argsId, offset) {\n  if (offset) {\n    path.parentPath.replaceWith(t.binaryExpression(\"-\", argsLengthExpression, t.numericLiteral(offset)));\n  } else {\n    path.replaceWith(argsId);\n  }\n}\n\nvar visitor = /*istanbul ignore next*/exports.visitor = { /*istanbul ignore next*/\n  Function: function Function(path) {\n    /*istanbul ignore next*/var node = path.node;\n    /*istanbul ignore next*/var scope = path.scope;\n\n    if (!hasRest(node)) return;\n\n    var rest = node.params.pop().argument;\n\n    var argsId = t.identifier(\"arguments\");\n    var argsLengthExpression = t.memberExpression(argsId, t.identifier(\"length\"));\n\n    // otherwise `arguments` will be remapped in arrow functions\n    argsId._shadowedFunctionLiteral = path;\n\n    // check and optimise for extremely common cases\n    var state = {\n      references: [],\n      offset: node.params.length,\n\n      argumentsNode: argsId,\n      outerBinding: scope.getBindingIdentifier(rest.name),\n\n      // candidate member expressions we could optimise if there are no other references\n      candidates: [],\n\n      // local rest binding name\n      name: rest.name,\n\n      /*\n      It may be possible to optimize the output code in certain ways, such as\n      not generating code to initialize an array (perhaps substituting direct\n      references to arguments[i] or arguments.length for reads of the\n      corresponding rest parameter property) or positioning the initialization\n      code so that it may not have to execute depending on runtime conditions.\n       This property tracks eligibility for optimization. \"deopted\" means give up\n      and don't perform optimization. For example, when any of rest's elements /\n      properties is assigned to at the top level, or referenced at all in a\n      nested function.\n      */\n      deopted: false\n    };\n\n    path.traverse(memberExpressionOptimisationVisitor, state);\n\n    // There are only \"shorthand\" references\n    if (!state.deopted && !state.references.length) {\n      for ( /*istanbul ignore next*/var _iterator = state.candidates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n        /*istanbul ignore next*/\n        var _ref2;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref2 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref2 = _i.value;\n        }\n\n        var _ref3 = _ref2;\n        var _path = _ref3.path;\n        /*istanbul ignore next*/var cause = _ref3.cause;\n\n        switch (cause) {\n          case \"indexGetter\":\n            optimiseIndexGetter(_path, argsId, state.offset);\n            break;\n          case \"lengthGetter\":\n            optimiseLengthGetter(_path, argsLengthExpression, argsId, state.offset);\n            break;\n          default:\n            _path.replaceWith(argsId);\n        }\n      }\n      return;\n    }\n\n    state.references = state.references.concat(state.candidates.map(function ( /*istanbul ignore next*/_ref4) /*istanbul ignore next*/{\n      var path = _ref4.path;\n      return path;\n    }));\n\n    // deopt shadowed functions as transforms like regenerator may try touch the allocation loop\n    state.deopted = state.deopted || !!node.shadow;\n\n    var start = t.numericLiteral(node.params.length);\n    var key = scope.generateUidIdentifier(\"key\");\n    var len = scope.generateUidIdentifier(\"len\");\n\n    var arrKey = key;\n    var arrLen = len;\n    if (node.params.length) {\n      // this method has additional params, so we need to subtract\n      // the index of the current argument position from the\n      // position in the array that we want to populate\n      arrKey = t.binaryExpression(\"-\", key, start);\n\n      // we need to work out the size of the array that we're\n      // going to store all the rest parameters\n      //\n      // we need to add a check to avoid constructing the array\n      // with <0 if there are less arguments than params as it'll\n      // cause an error\n      arrLen = t.conditionalExpression(t.binaryExpression(\">\", len, start), t.binaryExpression(\"-\", len, start), t.numericLiteral(0));\n    }\n\n    var loop = buildRest({\n      ARGUMENTS: argsId,\n      ARRAY_KEY: arrKey,\n      ARRAY_LEN: arrLen,\n      START: start,\n      ARRAY: rest,\n      KEY: key,\n      LEN: len\n    });\n\n    if (state.deopted) {\n      loop._blockHoist = node.params.length + 1;\n      node.body.body.unshift(loop);\n    } else {\n      // perform allocation at the lowest common ancestor of all references\n      loop._blockHoist = 1;\n\n      var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n\n      // don't perform the allocation inside a loop\n      target.findParent(function (path) {\n        if (path.isLoop()) {\n          target = path;\n        } else {\n          // Stop crawling up if this is a function.\n          return path.isFunction();\n        }\n      });\n\n      target.insertBefore(loop);\n    }\n  }\n};"]}