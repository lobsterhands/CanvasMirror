{"version":3,"sources":["index.js"],"names":[],"mappings":"wBAAwB;;AAExB,QAAQ,UAAR,GAAqB,IAArB;;AAEA,IAAI,mBAAmB,QAAQ,sCAAR,CAAvB;;AAEA,IAAI,mBAAmB,uBAAuB,gBAAvB,CAAvB;;AAEA,IAAI,gBAAgB,QAAQ,oCAAR,CAApB;;AAEA,IAAI,gBAAgB,uBAAuB,aAAvB,CAApB;;AAEA,QAAQ,OAAR,GAAkB,U,yBAAmC,IAAnC,EAAyC;0BACjC,IAAI,IAAI,KAAK,KAAb;;;;;;AAOxB,WAAS,6BAAT,CAAuC,IAAvC,EAA6C;AAC3C,S,yBAA8B,IAAI,YAAY,KAAK,YAArB,EAAmC,WAAW,MAAM,OAAN,CAAc,SAAd,CAA9C,EAAwE,KAAK,CAA7E,EAAgF,YAAY,WAAW,SAAX,GAAuB,CAAC,GAAG,cAAc,OAAlB,EAA2B,SAA3B,CAAjJ,IAA0L;;AAExL,UAAI,KAAJ;;AAEA,UAAI,QAAJ,EAAc;AACZ,YAAI,MAAM,UAAU,MAApB,EAA4B;AAC5B,gBAAQ,UAAU,IAAV,CAAR;AACD,OAHD,MAGO;AACL,aAAK,UAAU,IAAV,EAAL;AACA,YAAI,GAAG,IAAP,EAAa;AACb,gBAAQ,GAAG,KAAX;AACD;;AAED,UAAI,SAAS,KAAb;;AAEA,UAAI,EAAE,SAAF,CAAY,OAAO,EAAnB,CAAJ,EAA4B;AAC1B,eAAO,IAAP;AACD;AACF;AACD,WAAO,KAAP;AACD;;;;;;AAMD,WAAS,OAAT,CAAiB,OAAjB,EAA0B;AACxB,S,yBAA8B,IAAI,aAAa,QAAQ,QAAzB,EAAmC,YAAY,MAAM,OAAN,CAAc,UAAd,CAA/C,EAA0E,MAAM,CAAhF,EAAmF,aAAa,YAAY,UAAZ,GAAyB,CAAC,GAAG,cAAc,OAAlB,EAA2B,UAA3B,CAAvJ,IAAiM;;AAE/L,UAAI,KAAJ;;AAEA,UAAI,SAAJ,EAAe;AACb,YAAI,OAAO,WAAW,MAAtB,EAA8B;AAC9B,gBAAQ,WAAW,KAAX,CAAR;AACD,OAHD,MAGO;AACL,cAAM,WAAW,IAAX,EAAN;AACA,YAAI,IAAI,IAAR,EAAc;AACd,gBAAQ,IAAI,KAAZ;AACD;;AAED,UAAI,OAAO,KAAX;;AAEA,UAAI,EAAE,aAAF,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,eAAO,IAAP;AACD;AACF;AACD,WAAO,KAAP;AACD;;AAED,MAAI,qBAAqB,E;AACvB,0BAAsB,SAAS,oBAAT,CAA8B,IAA9B,EAAoC,KAApC,EAA2C;AAC/D,UAAI,MAAM,QAAN,CAAe,KAAK,IAAL,CAAU,IAAzB,CAAJ,EAAoC;AAClC,cAAM,KAAN,GAAc,IAAd;AACA,aAAK,IAAL;AACD;AACF;AANsB,GAAzB;;;AAUA,MAAI,2BAA2B,YAAY;AACzC,a,wBAAiC,wBAAjC,CAA0D,IAA1D,EAAgE;8BACtC,CAAC,GAAG,iBAAiB,OAArB,EAA8B,IAA9B,EAAoC,wBAApC;;AAExB,WAAK,UAAL,GAAkB,KAAK,UAAvB;AACA,WAAK,QAAL,GAAgB,KAAK,QAArB;AACA,WAAK,MAAL,GAAc,EAAd;AACA,WAAK,KAAL,GAAa,KAAK,KAAL,IAAc,EAA3B;AACA,WAAK,KAAL,GAAa,KAAK,KAAlB;AACA,WAAK,IAAL,GAAY,KAAK,IAAjB;AACA,WAAK,IAAL,GAAY,KAAK,IAAjB;AACD;;AAED,6BAAyB,SAAzB,CAAmC,uBAAnC,GAA6D,SAAS,uBAAT,CAAiC,EAAjC,EAAqC,IAArC,EAA2C;AACtG,UAAI,KAAK,KAAK,QAAd;AACA,UAAI,EAAE,kBAAF,CAAqB,EAArB,CAAJ,EAA8B,KAAK,GAAL;;AAE9B,UAAI,O,wBAA+B,KAAK,CAAxC;;AAEA,UAAI,EAAJ,EAAQ;AACN,eAAO,EAAE,mBAAF,CAAsB,EAAE,oBAAF,CAAuB,EAAvB,EAA2B,EAA3B,EAA+B,IAA/B,CAAtB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,EAAE,mBAAF,CAAsB,KAAK,IAA3B,EAAiC,CAAC,EAAE,kBAAF,CAAqB,EAArB,EAAyB,IAAzB,CAAD,CAAjC,CAAP;AACD;;AAED,WAAK,WAAL,GAAmB,KAAK,UAAxB;;AAEA,aAAO,IAAP;AACD,KAfD;;AAiBA,6BAAyB,SAAzB,CAAmC,wBAAnC,GAA8D,SAAS,wBAAT,CAAkC,EAAlC,EAAsC,IAAtC,EAA4C;AACxG,UAAI,SAAS,EAAE,mBAAF,CAAsB,KAAtB,EAA6B,CAAC,EAAE,kBAAF,CAAqB,EAArB,EAAyB,IAAzB,CAAD,CAA7B,CAAb;AACA,aAAO,WAAP,GAAqB,KAAK,UAA1B;AACA,aAAO,MAAP;AACD,KAJD;;AAMA,6BAAyB,SAAzB,CAAmC,IAAnC,GAA0C,SAAS,IAAT,CAAc,EAAd,EAAkB,IAAlB,EAAwB;AAChE,UAAI,EAAE,eAAF,CAAkB,EAAlB,CAAJ,EAA2B;AACzB,aAAK,iBAAL,CAAuB,EAAvB,EAA2B,IAA3B;AACD,OAFD,MAEO,IAAI,EAAE,cAAF,CAAiB,EAAjB,CAAJ,EAA0B;AAC/B,aAAK,gBAAL,CAAsB,EAAtB,EAA0B,IAA1B;AACD,OAFM,MAEA,IAAI,EAAE,mBAAF,CAAsB,EAAtB,CAAJ,EAA+B;AACpC,aAAK,qBAAL,CAA2B,EAA3B,EAA+B,IAA/B;AACD,OAFM,MAEA;AACL,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,uBAAL,CAA6B,EAA7B,EAAiC,IAAjC,CAAhB;AACD;AACF,KAVD;;AAYA,6BAAyB,SAAzB,CAAmC,OAAnC,GAA6C,SAAS,OAAT,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B;AACzE,UAAI,KAAK,IAAL,CAAU,IAAV,CAAe,KAAf,IAAwB,EAAE,YAAF,CAAe,IAAf,KAAwB,KAAK,MAAL,CAAY,KAAK,IAAjB,CAApD,EAA4E;AAC1E,eAAO,IAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAK,KAAL,CAAW,OAAX,CAAmB,IAAnB,EAAyB,KAAzB,CAAP;AACD;AACF,KAND;;AAQA,6BAAyB,SAAzB,CAAmC,qBAAnC,GAA2D,SAAS,qBAAT,CAA+B,OAA/B,EAAwC,QAAxC,EAAkD;;;;AAI3G,UAAI,eAAe,KAAK,KAAL,CAAW,gCAAX,CAA4C,QAA5C,CAAnB;;AAEA,UAAI,SAAS,EAAE,mBAAF,CAAsB,KAAtB,EAA6B,CAAC,EAAE,kBAAF,CAAqB,YAArB,EAAmC,QAAnC,CAAD,CAA7B,CAAb;AACA,aAAO,WAAP,GAAqB,KAAK,UAA1B;AACA,WAAK,KAAL,CAAW,IAAX,CAAgB,MAAhB;;;;AAIA,UAAI,kBAAkB,EAAE,qBAAF,CAAwB,EAAE,gBAAF,CAAmB,KAAnB,EAA0B,YAA1B,EAAwC,EAAE,UAAF,CAAa,WAAb,CAAxC,CAAxB,EAA4F,QAAQ,KAApG,EAA2G,YAA3G,CAAtB;;AAEA,UAAI,OAAO,QAAQ,IAAnB;AACA,UAAI,EAAE,SAAF,CAAY,IAAZ,CAAJ,EAAuB;AACrB,YAAI,mBAAmB,EAAE,mBAAF,CAAsB,EAAE,oBAAF,CAAuB,GAAvB,EAA4B,YAA5B,EAA0C,eAA1C,CAAtB,CAAvB;AACA,yBAAiB,WAAjB,GAA+B,KAAK,UAApC;;AAEA,aAAK,KAAL,CAAW,IAAX,CAAgB,gBAAhB;AACA,aAAK,IAAL,CAAU,IAAV,EAAgB,YAAhB;AACD,OAND,MAMO;AACL,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,eAAnC,CAAhB;AACD;AACF,KAxBD;;AA0BA,6BAAyB,SAAzB,CAAmC,cAAnC,GAAoD,SAAS,cAAT,CAAwB,OAAxB,EAAiC,MAAjC,EAAyC,UAAzC,EAAqD,eAArD,EAAsE;;;AAGxH,UAAI,OAAO,EAAX;;AAEA,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,UAAR,CAAmB,MAAvC,EAA+C,GAA/C,EAAoD;AAClD,YAAI,OAAO,QAAQ,UAAR,CAAmB,CAAnB,CAAX;;;;AAIA,YAAI,KAAK,eAAT,EAA0B;;;AAG1B,YAAI,EAAE,cAAF,CAAiB,IAAjB,CAAJ,EAA4B;;AAE5B,YAAI,MAAM,KAAK,GAAf;AACA,YAAI,EAAE,YAAF,CAAe,GAAf,KAAuB,CAAC,KAAK,QAAjC,EAA2C,MAAM,EAAE,aAAF,CAAgB,KAAK,GAAL,CAAS,IAAzB,CAAN;AAC3C,aAAK,IAAL,CAAU,GAAV;AACD;;AAED,aAAO,EAAE,eAAF,CAAkB,IAAlB,CAAP;;;;AAIA,UAAI,QAAQ,EAAE,cAAF,CAAiB,KAAK,IAAL,CAAU,SAAV,CAAoB,yBAApB,CAAjB,EAAiE,CAAC,MAAD,EAAS,IAAT,CAAjE,CAAZ;AACA,WAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,uBAAL,CAA6B,WAAW,QAAxC,EAAkD,KAAlD,CAAhB;AACD,KA1BD;;AA4BA,6BAAyB,SAAzB,CAAmC,kBAAnC,GAAwD,SAAS,kBAAT,CAA4B,IAA5B,EAAkC,OAAlC,EAA2C;AACjG,UAAI,EAAE,SAAF,CAAY,KAAK,GAAjB,CAAJ,EAA2B,KAAK,QAAL,GAAgB,IAAhB;;AAE3B,UAAI,UAAU,KAAK,KAAnB;AACA,UAAI,SAAS,EAAE,gBAAF,CAAmB,OAAnB,EAA4B,KAAK,GAAjC,EAAsC,KAAK,QAA3C,CAAb;;AAEA,UAAI,EAAE,SAAF,CAAY,OAAZ,CAAJ,EAA0B;AACxB,aAAK,IAAL,CAAU,OAAV,EAAmB,MAAnB;AACD,OAFD,MAEO;AACL,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,uBAAL,CAA6B,OAA7B,EAAsC,MAAtC,CAAhB;AACD;AACF,KAXD;;AAaA,6BAAyB,SAAzB,CAAmC,iBAAnC,GAAuD,SAAS,iBAAT,CAA2B,OAA3B,EAAoC,MAApC,EAA4C;;;AAGjG,UAAI,CAAC,QAAQ,UAAR,CAAmB,MAAxB,EAAgC;AAC9B,aAAK,KAAL,CAAW,IAAX,CAAgB,EAAE,mBAAF,CAAsB,EAAE,cAAF,CAAiB,KAAK,IAAL,CAAU,SAAV,CAAoB,0BAApB,CAAjB,EAAkE,CAAC,MAAD,CAAlE,CAAtB,CAAhB;AACD;;;;;;AAMD,UAAI,QAAQ,UAAR,CAAmB,MAAnB,GAA4B,CAA5B,IAAiC,CAAC,KAAK,KAAL,CAAW,QAAX,CAAoB,MAApB,CAAtC,EAAmE;AACjE,YAAI,OAAO,KAAK,KAAL,CAAW,gCAAX,CAA4C,MAA5C,CAAX;AACA,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,wBAAL,CAA8B,IAA9B,EAAoC,MAApC,CAAhB;AACA,iBAAS,IAAT;AACD;;;;AAID,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,UAAR,CAAmB,MAAvC,EAA+C,GAA/C,EAAoD;AAClD,YAAI,OAAO,QAAQ,UAAR,CAAmB,CAAnB,CAAX;AACA,YAAI,EAAE,cAAF,CAAiB,IAAjB,CAAJ,EAA4B;AAC1B,eAAK,cAAL,CAAoB,OAApB,EAA6B,MAA7B,EAAqC,IAArC,EAA2C,CAA3C;AACD,SAFD,MAEO;AACL,eAAK,kBAAL,CAAwB,IAAxB,EAA8B,MAA9B;AACD;AACF;AACF,KA3BD;;AA6BA,6BAAyB,SAAzB,CAAmC,qBAAnC,GAA2D,SAAS,qBAAT,CAA+B,OAA/B,EAAwC,GAAxC,EAA6C;;AAEtG,UAAI,CAAC,EAAE,iBAAF,CAAoB,GAApB,CAAL,EAA+B,OAAO,KAAP;;;;AAI/B,UAAI,QAAQ,QAAR,CAAiB,MAAjB,GAA0B,IAAI,QAAJ,CAAa,MAA3C,EAAmD;AACnD,UAAI,QAAQ,QAAR,CAAiB,MAAjB,GAA0B,IAAI,QAAJ,CAAa,MAAvC,IAAiD,CAAC,QAAQ,OAAR,CAAtD,EAAwE,OAAO,KAAP;;AAExE,W,yBAA8B,IAAI,aAAa,QAAQ,QAAzB,EAAmC,YAAY,MAAM,OAAN,CAAc,UAAd,CAA/C,EAA0E,MAAM,CAAhF,EAAmF,aAAa,YAAY,UAAZ,GAAyB,CAAC,GAAG,cAAc,OAAlB,EAA2B,UAA3B,CAAvJ,IAAiM;;AAE/L,YAAI,KAAJ;;AAEA,YAAI,SAAJ,EAAe;AACb,cAAI,OAAO,WAAW,MAAtB,EAA8B;AAC9B,kBAAQ,WAAW,KAAX,CAAR;AACD,SAHD,MAGO;AACL,gBAAM,WAAW,IAAX,EAAN;AACA,cAAI,IAAI,IAAR,EAAc;AACd,kBAAQ,IAAI,KAAZ;AACD;;AAED,YAAI,OAAO,KAAX;;;AAGA,YAAI,CAAC,IAAL,EAAW,OAAO,KAAP;;;AAGX,YAAI,EAAE,kBAAF,CAAqB,IAArB,CAAJ,EAAgC,OAAO,KAAP;AACjC;;AAED,W,yBAA8B,IAAI,aAAa,IAAI,QAArB,EAA+B,YAAY,MAAM,OAAN,CAAc,UAAd,CAA3C,EAAsE,MAAM,CAA5E,EAA+E,aAAa,YAAY,UAAZ,GAAyB,CAAC,GAAG,cAAc,OAAlB,EAA2B,UAA3B,CAAnJ,IAA6L;;AAE3L,YAAI,KAAJ;;AAEA,YAAI,SAAJ,EAAe;AACb,cAAI,OAAO,WAAW,MAAtB,EAA8B;AAC9B,kBAAQ,WAAW,KAAX,CAAR;AACD,SAHD,MAGO;AACL,gBAAM,WAAW,IAAX,EAAN;AACA,cAAI,IAAI,IAAR,EAAc;AACd,kBAAQ,IAAI,KAAZ;AACD;;AAED,YAAI,QAAQ,KAAZ;;;AAGA,YAAI,EAAE,eAAF,CAAkB,KAAlB,CAAJ,EAA8B,OAAO,KAAP;AAC/B;;;AAGD,UAAI,WAAW,EAAE,qBAAF,CAAwB,OAAxB,CAAf;AACA,UAAI,QAAQ,EAAE,OAAO,KAAT,EAAgB,UAAU,QAA1B,EAAZ;AACA,WAAK,KAAL,CAAW,QAAX,CAAoB,GAApB,EAAyB,kBAAzB,EAA6C,KAA7C;AACA,aAAO,CAAC,MAAM,KAAd;AACD,KAvDD;;AAyDA,6BAAyB,SAAzB,CAAmC,wBAAnC,GAA8D,SAAS,wBAAT,CAAkC,OAAlC,EAA2C,GAA3C,EAAgD;AAC5G,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,QAAR,CAAiB,MAArC,EAA6C,GAA7C,EAAkD;AAChD,YAAI,OAAO,QAAQ,QAAR,CAAiB,CAAjB,CAAX;AACA,YAAI,EAAE,aAAF,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,eAAK,IAAL,CAAU,KAAK,QAAf,EAAyB,EAAE,eAAF,CAAkB,IAAI,QAAJ,CAAa,KAAb,CAAmB,CAAnB,CAAlB,CAAzB;AACD,SAFD,MAEO;AACL,eAAK,IAAL,CAAU,IAAV,EAAgB,IAAI,QAAJ,CAAa,CAAb,CAAhB;AACD;AACF;AACF,KATD;;AAWA,6BAAyB,SAAzB,CAAmC,gBAAnC,GAAsD,SAAS,gBAAT,CAA0B,OAA1B,EAAmC,QAAnC,EAA6C;AACjG,UAAI,CAAC,QAAQ,QAAb,EAAuB;;;;;;;;;AASvB,UAAI,KAAK,qBAAL,CAA2B,OAA3B,EAAoC,QAApC,CAAJ,EAAmD;AACjD,eAAO,KAAK,wBAAL,CAA8B,OAA9B,EAAuC,QAAvC,CAAP;AACD;;;;;AAKD,UAAI,QAAQ,CAAC,QAAQ,OAAR,CAAD,IAAqB,QAAQ,QAAR,CAAiB,MAAlD;;;;;;AAMA,UAAI,UAAU,KAAK,OAAL,CAAa,QAAb,EAAuB,KAAvB,CAAd;;AAEA,UAAI,EAAE,YAAF,CAAe,OAAf,CAAJ,EAA6B;;;AAG3B,mBAAW,OAAX;AACD,OAJD,MAIO;AACL,mBAAW,KAAK,KAAL,CAAW,gCAAX,CAA4C,QAA5C,CAAX;AACA,aAAK,MAAL,CAAY,SAAS,IAArB,IAA6B,IAA7B;AACA,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,wBAAL,CAA8B,QAA9B,EAAwC,OAAxC,CAAhB;AACD;;;;AAID,WAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,QAAR,CAAiB,MAArC,EAA6C,GAA7C,EAAkD;AAChD,YAAI,OAAO,QAAQ,QAAR,CAAiB,CAAjB,CAAX;;;AAGA,YAAI,CAAC,IAAL,EAAW;;AAEX,YAAI,U,wBAAkC,KAAK,CAA3C;;AAEA,YAAI,EAAE,aAAF,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,oBAAU,KAAK,OAAL,CAAa,QAAb,CAAV;;AAEA,cAAI,IAAI,CAAR,EAAW;AACT,sBAAU,EAAE,cAAF,CAAiB,EAAE,gBAAF,CAAmB,OAAnB,EAA4B,EAAE,UAAF,CAAa,OAAb,CAA5B,CAAjB,EAAqE,CAAC,EAAE,cAAF,CAAiB,CAAjB,CAAD,CAArE,CAAV;AACD;;;;AAID,iBAAO,KAAK,QAAZ;AACD,SAVD,MAUO;AACL,oBAAU,EAAE,gBAAF,CAAmB,QAAnB,EAA6B,EAAE,cAAF,CAAiB,CAAjB,CAA7B,EAAkD,IAAlD,CAAV;AACD;;AAED,aAAK,IAAL,CAAU,IAAV,EAAgB,OAAhB;AACD;AACF,KA7DD;;AA+DA,6BAAyB,SAAzB,CAAmC,IAAnC,GAA0C,SAAS,IAAT,CAAc,OAAd,EAAuB,GAAvB,EAA4B;;;;AAIpE,UAAI,CAAC,EAAE,iBAAF,CAAoB,GAApB,CAAD,IAA6B,CAAC,EAAE,kBAAF,CAAqB,GAArB,CAAlC,EAA6D;AAC3D,YAAI,OAAO,KAAK,KAAL,CAAW,qBAAX,CAAiC,GAAjC,EAAsC,IAAtC,CAAX;AACA,YAAI,IAAJ,EAAU;AACR,eAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,wBAAL,CAA8B,IAA9B,EAAoC,GAApC,CAAhB;AACA,gBAAM,IAAN;AACD;AACF;;;;AAID,WAAK,IAAL,CAAU,OAAV,EAAmB,GAAnB;;AAEA,aAAO,KAAK,KAAZ;AACD,KAjBD;;AAmBA,WAAO,wBAAP;AACD,GA/S8B,EAA/B;;AAiTA,SAAO;AACL,aAAS,E;AACP,8BAAwB,SAAS,sBAAT,CAAgC,IAAhC,EAAsC;AAC5D,YAAI,cAAc,KAAK,GAAL,CAAS,aAAT,CAAlB;AACA,YAAI,CAAC,YAAY,qBAAZ,EAAL,EAA0C;AAC1C,YAAI,CAAC,8BAA8B,YAAY,IAA1C,CAAL,EAAsD;;AAEtD,YAAI,aAAa,EAAjB;;AAEA,aAAK,IAAI,IAAT,IAAiB,KAAK,0BAAL,CAAgC,IAAhC,CAAjB,EAAwD;AACtD,cAAI,KAAK,EAAE,UAAF,CAAa,IAAb,CAAT;AACA,qBAAW,IAAX,CAAgB,EAAE,eAAF,CAAkB,EAAlB,EAAsB,EAAtB,CAAhB;AACD;;;;;AAKD,aAAK,WAAL,CAAiB,YAAY,IAA7B;AACA,aAAK,WAAL,CAAiB,EAAE,sBAAF,CAAyB,IAAzB,EAA+B,UAA/B,CAAjB;AACD,OAlBM;8BAmBiB,eAAe,SAAS,aAAT,CAAuB,IAAvB,EAA6B,IAA7B,EAAmC;gCAChD,IAAI,OAAO,KAAK,IAAhB;gCACA,IAAI,QAAQ,KAAK,KAAjB;;AAExB,YAAI,OAAO,KAAK,IAAhB;;AAEA,YAAI,EAAE,SAAF,CAAY,IAAZ,CAAJ,EAAuB;;;AAGrB,cAAI,OAAO,MAAM,qBAAN,CAA4B,KAA5B,CAAX;;AAEA,eAAK,IAAL,GAAY,EAAE,mBAAF,CAAsB,KAAtB,EAA6B,CAAC,EAAE,kBAAF,CAAqB,IAArB,CAAD,CAA7B,CAAZ;;AAEA,eAAK,WAAL;;AAEA,eAAK,IAAL,CAAU,IAAV,CAAe,OAAf,CAAuB,EAAE,mBAAF,CAAsB,KAAtB,EAA6B,CAAC,EAAE,kBAAF,CAAqB,IAArB,EAA2B,IAA3B,CAAD,CAA7B,CAAvB;;AAEA;AACD;;AAED,YAAI,CAAC,EAAE,qBAAF,CAAwB,IAAxB,CAAL,EAAoC;;AAEpC,YAAI,UAAU,KAAK,YAAL,CAAkB,CAAlB,EAAqB,EAAnC;AACA,YAAI,CAAC,EAAE,SAAF,CAAY,OAAZ,CAAL,EAA2B;;AAE3B,YAAI,MAAM,MAAM,qBAAN,CAA4B,KAA5B,CAAV;AACA,aAAK,IAAL,GAAY,EAAE,mBAAF,CAAsB,KAAK,IAA3B,EAAiC,CAAC,EAAE,kBAAF,CAAqB,GAArB,EAA0B,IAA1B,CAAD,CAAjC,CAAZ;;AAEA,YAAI,QAAQ,EAAZ;;AAEA,YAAI,gBAAgB,IAAI,wBAAJ,CAA6B;AAC/C,gBAAM,KAAK,IADoC;AAE/C,gBAAM,IAFyC;AAG/C,iBAAO,KAHwC;AAI/C,iBAAO;AAJwC,SAA7B,CAApB;;AAOA,sBAAc,IAAd,CAAmB,OAAnB,EAA4B,GAA5B;;AAEA,aAAK,WAAL;;AAEA,YAAI,QAAQ,KAAK,IAAjB;AACA,cAAM,IAAN,GAAa,MAAM,MAAN,CAAa,MAAM,IAAnB,CAAb;AACD,OA9DM;8BA+DiB,aAAa,SAAS,WAAT,CAAqB,KAArB,EAA4B,IAA5B,EAAkC;gCAC7C,IAAI,OAAO,MAAM,IAAjB;gCACA,IAAI,QAAQ,MAAM,KAAlB;;AAExB,YAAI,UAAU,KAAK,KAAnB;AACA,YAAI,CAAC,EAAE,SAAF,CAAY,OAAZ,CAAL,EAA2B;;AAE3B,YAAI,MAAM,MAAM,qBAAN,CAA4B,KAA5B,CAAV;AACA,aAAK,KAAL,GAAa,GAAb;;AAEA,YAAI,QAAQ,EAAZ;;AAEA,YAAI,gBAAgB,IAAI,wBAAJ,CAA6B;AAC/C,gBAAM,KADyC;AAE/C,gBAAM,IAFyC;AAG/C,iBAAO,KAHwC;AAI/C,iBAAO;AAJwC,SAA7B,CAApB;AAMA,sBAAc,IAAd,CAAmB,OAAnB,EAA4B,GAA5B;;AAEA,aAAK,IAAL,CAAU,IAAV,GAAiB,MAAM,MAAN,CAAa,KAAK,IAAL,CAAU,IAAvB,CAAjB;AACD,OApFM;8BAqFiB,sBAAsB,SAAS,oBAAT,CAA8B,IAA9B,EAAoC,IAApC,EAA0C;gCAC9D,IAAI,OAAO,KAAK,IAAhB;gCACA,IAAI,QAAQ,KAAK,KAAjB;;AAExB,YAAI,CAAC,EAAE,SAAF,CAAY,KAAK,IAAjB,CAAL,EAA6B;;AAE7B,YAAI,QAAQ,EAAZ;;AAEA,YAAI,gBAAgB,IAAI,wBAAJ,CAA6B;AAC/C,oBAAU,KAAK,QADgC;AAE/C,gBAAM,IAFyC;AAG/C,iBAAO,KAHwC;AAI/C,iBAAO;AAJwC,SAA7B,CAApB;;AAOA,YAAI,M,wBAA8B,KAAK,CAAvC;AACA,YAAI,KAAK,kBAAL,MAA6B,CAAC,KAAK,UAAL,CAAgB,qBAAhB,EAAlC,EAA2E;AACzE,gBAAM,MAAM,gCAAN,CAAuC,KAAK,KAA5C,EAAmD,KAAnD,CAAN;;AAEA,gBAAM,IAAN,CAAW,EAAE,mBAAF,CAAsB,KAAtB,EAA6B,CAAC,EAAE,kBAAF,CAAqB,GAArB,EAA0B,KAAK,KAA/B,CAAD,CAA7B,CAAX;;AAEA,cAAI,EAAE,iBAAF,CAAoB,KAAK,KAAzB,CAAJ,EAAqC;AACnC,0BAAc,MAAd,CAAqB,IAAI,IAAzB,IAAiC,IAAjC;AACD;AACF;;AAED,sBAAc,IAAd,CAAmB,KAAK,IAAxB,EAA8B,OAAO,KAAK,KAA1C;;AAEA,YAAI,GAAJ,EAAS;AACP,gBAAM,IAAN,CAAW,EAAE,mBAAF,CAAsB,GAAtB,CAAX;AACD;;AAED,aAAK,mBAAL,CAAyB,KAAzB;AACD,OAtHM;8BAuHiB,qBAAqB,SAAS,mBAAT,CAA6B,IAA7B,EAAmC,IAAnC,EAAyC;gCAC5D,IAAI,OAAO,KAAK,IAAhB;gCACA,IAAI,QAAQ,KAAK,KAAjB;gCACA,IAAI,SAAS,KAAK,MAAlB;;AAExB,YAAI,EAAE,eAAF,CAAkB,MAAlB,CAAJ,EAA+B;AAC/B,YAAI,CAAC,MAAD,IAAW,CAAC,KAAK,SAArB,EAAgC,O;AAChC,YAAI,CAAC,8BAA8B,IAA9B,CAAL,EAA0C;;AAE1C,YAAI,QAAQ,EAAZ;AACA,YAAI,S,wBAAiC,KAAK,CAA1C;;AAEA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,YAAL,CAAkB,MAAtC,EAA8C,GAA9C,EAAmD;AACjD,mBAAS,KAAK,YAAL,CAAkB,CAAlB,CAAT;;AAEA,cAAI,YAAY,OAAO,IAAvB;AACA,cAAI,UAAU,OAAO,EAArB;;AAEA,cAAI,gBAAgB,IAAI,wBAAJ,CAA6B;AAC/C,wBAAY,KAAK,WAD8B;AAE/C,mBAAO,KAFwC;AAG/C,mBAAO,KAHwC;AAI/C,kBAAM,KAAK,IAJoC;AAK/C,kBAAM;AALyC,WAA7B,CAApB;;AAQA,cAAI,EAAE,SAAF,CAAY,OAAZ,CAAJ,EAA0B;AACxB,0BAAc,IAAd,CAAmB,OAAnB,EAA4B,SAA5B;;AAEA,gBAAI,CAAC,CAAD,KAAO,KAAK,YAAL,CAAkB,MAAlB,GAA2B,CAAtC,EAAyC;;;AAGvC,gBAAE,QAAF,CAAW,MAAM,MAAM,MAAN,GAAe,CAArB,CAAX,EAAoC,MAApC;AACD;AACF,WARD,MAQO;AACL,kBAAM,IAAN,CAAW,EAAE,QAAF,CAAW,cAAc,uBAAd,CAAsC,OAAO,EAA7C,EAAiD,OAAO,IAAxD,CAAX,EAA0E,MAA1E,CAAX;AACD;AACF;;AAED,aAAK,mBAAL,CAAyB,KAAzB;AACD;AA/JM;AADJ,GAAP;AAmKD,CAxhBD;;;AA2hBA,SAAS,sBAAT,CAAgC,GAAhC,EAAqC;AAAE,SAAO,OAAO,IAAI,UAAX,GAAwB,GAAxB,GAA8B,EAAE,SAAS,GAAX,EAArC;AAAwD;;AAE/F,OAAO,OAAP,GAAiB,QAAQ,SAAR,CAAjB,C","file":"index-compiled.js","sourcesContent":["/*istanbul ignore next*/\"use strict\";\n\nexports.__esModule = true;\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _getIterator2 = require(\"babel-runtime/core-js/get-iterator\");\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nexports.default = function ( /*istanbul ignore next*/_ref) {\n  /*istanbul ignore next*/var t = _ref.types;\n\n\n  /**\n   * Test if a VariableDeclaration's declarations contains any Patterns.\n   */\n\n  function variableDeclarationHasPattern(node) {\n    for ( /*istanbul ignore next*/var _iterator = node.declarations, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      /*istanbul ignore next*/\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var declar = _ref2;\n\n      if (t.isPattern(declar.id)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Test if an ArrayPattern's elements contain any RestElements.\n   */\n\n  function hasRest(pattern) {\n    for ( /*istanbul ignore next*/var _iterator2 = pattern.elements, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      /*istanbul ignore next*/\n      var _ref3;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref3 = _i2.value;\n      }\n\n      var elem = _ref3;\n\n      if (t.isRestElement(elem)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var arrayUnpackVisitor = { /*istanbul ignore next*/\n    ReferencedIdentifier: function ReferencedIdentifier(path, state) {\n      if (state.bindings[path.node.name]) {\n        state.deopt = true;\n        path.stop();\n      }\n    }\n  };\n\n  /*istanbul ignore next*/\n  var DestructuringTransformer = function () {\n    function /*istanbul ignore next*/DestructuringTransformer(opts) {\n      /*istanbul ignore next*/(0, _classCallCheck3.default)(this, DestructuringTransformer);\n\n      this.blockHoist = opts.blockHoist;\n      this.operator = opts.operator;\n      this.arrays = {};\n      this.nodes = opts.nodes || [];\n      this.scope = opts.scope;\n      this.file = opts.file;\n      this.kind = opts.kind;\n    }\n\n    DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) {\n      var op = this.operator;\n      if (t.isMemberExpression(id)) op = \"=\";\n\n      var node = /*istanbul ignore next*/void 0;\n\n      if (op) {\n        node = t.expressionStatement(t.assignmentExpression(op, id, init));\n      } else {\n        node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);\n      }\n\n      node._blockHoist = this.blockHoist;\n\n      return node;\n    };\n\n    DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) {\n      var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(id, init)]);\n      declar._blockHoist = this.blockHoist;\n      return declar;\n    };\n\n    DestructuringTransformer.prototype.push = function push(id, init) {\n      if (t.isObjectPattern(id)) {\n        this.pushObjectPattern(id, init);\n      } else if (t.isArrayPattern(id)) {\n        this.pushArrayPattern(id, init);\n      } else if (t.isAssignmentPattern(id)) {\n        this.pushAssignmentPattern(id, init);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(id, init));\n      }\n    };\n\n    DestructuringTransformer.prototype.toArray = function toArray(node, count) {\n      if (this.file.opts.loose || t.isIdentifier(node) && this.arrays[node.name]) {\n        return node;\n      } else {\n        return this.scope.toArray(node, count);\n      }\n    };\n\n    DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) {\n      // we need to assign the current value of the assignment to avoid evaluating\n      // it more than once\n\n      var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n      var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(tempValueRef, valueRef)]);\n      declar._blockHoist = this.blockHoist;\n      this.nodes.push(declar);\n\n      //\n\n      var tempConditional = t.conditionalExpression(t.binaryExpression(\"===\", tempValueRef, t.identifier(\"undefined\")), pattern.right, tempValueRef);\n\n      var left = pattern.left;\n      if (t.isPattern(left)) {\n        var tempValueDefault = t.expressionStatement(t.assignmentExpression(\"=\", tempValueRef, tempConditional));\n        tempValueDefault._blockHoist = this.blockHoist;\n\n        this.nodes.push(tempValueDefault);\n        this.push(left, tempValueRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n      }\n    };\n\n    DestructuringTransformer.prototype.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {\n      // get all the keys that appear in this object before the current spread\n\n      var keys = [];\n\n      for (var i = 0; i < pattern.properties.length; i++) {\n        var prop = pattern.properties[i];\n\n        // we've exceeded the index of the spread property to all properties to the\n        // right need to be ignored\n        if (i >= spreadPropIndex) break;\n\n        // ignore other spread properties\n        if (t.isRestProperty(prop)) continue;\n\n        var key = prop.key;\n        if (t.isIdentifier(key) && !prop.computed) key = t.stringLiteral(prop.key.name);\n        keys.push(key);\n      }\n\n      keys = t.arrayExpression(keys);\n\n      //\n\n      var value = t.callExpression(this.file.addHelper(\"objectWithoutProperties\"), [objRef, keys]);\n      this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n    };\n\n    DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) {\n      if (t.isLiteral(prop.key)) prop.computed = true;\n\n      var pattern = prop.value;\n      var objRef = t.memberExpression(propRef, prop.key, prop.computed);\n\n      if (t.isPattern(pattern)) {\n        this.push(pattern, objRef);\n      } else {\n        this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n      }\n    };\n\n    DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) {\n      // https://github.com/babel/babel/issues/681\n\n      if (!pattern.properties.length) {\n        this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper(\"objectDestructuringEmpty\"), [objRef])));\n      }\n\n      // if we have more than one properties in this pattern and the objectRef is a\n      // member expression then we need to assign it to a temporary variable so it's\n      // only evaluated once\n\n      if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n        var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n        this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n        objRef = temp;\n      }\n\n      //\n\n      for (var i = 0; i < pattern.properties.length; i++) {\n        var prop = pattern.properties[i];\n        if (t.isRestProperty(prop)) {\n          this.pushObjectRest(pattern, objRef, prop, i);\n        } else {\n          this.pushObjectProperty(prop, objRef);\n        }\n      }\n    };\n\n    DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {\n      // not an array so there's no way we can deal with this\n      if (!t.isArrayExpression(arr)) return false;\n\n      // pattern has less elements than the array and doesn't have a rest so some\n      // elements wont be evaluated\n      if (pattern.elements.length > arr.elements.length) return;\n      if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false;\n\n      for ( /*istanbul ignore next*/var _iterator3 = pattern.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n        /*istanbul ignore next*/\n        var _ref4;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n\n        var elem = _ref4;\n\n        // deopt on holes\n        if (!elem) return false;\n\n        // deopt on member expressions as they may be included in the RHS\n        if (t.isMemberExpression(elem)) return false;\n      }\n\n      for ( /*istanbul ignore next*/var _iterator4 = arr.elements, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n        /*istanbul ignore next*/\n        var _ref5;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref5 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref5 = _i4.value;\n        }\n\n        var _elem = _ref5;\n\n        // deopt on spread elements\n        if (t.isSpreadElement(_elem)) return false;\n      }\n\n      // deopt on reference to left side identifiers\n      var bindings = t.getBindingIdentifiers(pattern);\n      var state = { deopt: false, bindings: bindings };\n      this.scope.traverse(arr, arrayUnpackVisitor, state);\n      return !state.deopt;\n    };\n\n    DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {\n      for (var i = 0; i < pattern.elements.length; i++) {\n        var elem = pattern.elements[i];\n        if (t.isRestElement(elem)) {\n          this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));\n        } else {\n          this.push(elem, arr.elements[i]);\n        }\n      }\n    };\n\n    DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {\n      if (!pattern.elements) return;\n\n      // optimise basic array destructuring of an array expression\n      //\n      // we can't do this to a pattern of unequal size to it's right hand\n      // array expression as then there will be values that wont be evaluated\n      //\n      // eg: let [a, b] = [1, 2];\n\n      if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n        return this.pushUnpackedArrayPattern(pattern, arrayRef);\n      }\n\n      // if we have a rest then we need all the elements so don't tell\n      // `scope.toArray` to only get a certain amount\n\n      var count = !hasRest(pattern) && pattern.elements.length;\n\n      // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n      // return a locally bound identifier if it's been inferred to be an array,\n      // otherwise it'll be a call to a helper that will ensure it's one\n\n      var toArray = this.toArray(arrayRef, count);\n\n      if (t.isIdentifier(toArray)) {\n        // we've been given an identifier so it must have been inferred to be an\n        // array\n        arrayRef = toArray;\n      } else {\n        arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n        this.arrays[arrayRef.name] = true;\n        this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n      }\n\n      //\n\n      for (var i = 0; i < pattern.elements.length; i++) {\n        var elem = pattern.elements[i];\n\n        // hole\n        if (!elem) continue;\n\n        var elemRef = /*istanbul ignore next*/void 0;\n\n        if (t.isRestElement(elem)) {\n          elemRef = this.toArray(arrayRef);\n\n          if (i > 0) {\n            elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier(\"slice\")), [t.numericLiteral(i)]);\n          }\n\n          // set the element to the rest element argument since we've dealt with it\n          // being a rest already\n          elem = elem.argument;\n        } else {\n          elemRef = t.memberExpression(arrayRef, t.numericLiteral(i), true);\n        }\n\n        this.push(elem, elemRef);\n      }\n    };\n\n    DestructuringTransformer.prototype.init = function init(pattern, ref) {\n      // trying to destructure a value that we can't evaluate more than once so we\n      // need to save it to a variable\n\n      if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n        var memo = this.scope.maybeGenerateMemoised(ref, true);\n        if (memo) {\n          this.nodes.push(this.buildVariableDeclaration(memo, ref));\n          ref = memo;\n        }\n      }\n\n      //\n\n      this.push(pattern, ref);\n\n      return this.nodes;\n    };\n\n    return DestructuringTransformer;\n  }();\n\n  return {\n    visitor: { /*istanbul ignore next*/\n      ExportNamedDeclaration: function ExportNamedDeclaration(path) {\n        var declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        if (!variableDeclarationHasPattern(declaration.node)) return;\n\n        var specifiers = [];\n\n        for (var name in path.getOuterBindingIdentifiers(path)) {\n          var id = t.identifier(name);\n          specifiers.push(t.exportSpecifier(id, id));\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n      },\n      /*istanbul ignore next*/ForXStatement: function ForXStatement(path, file) {\n        /*istanbul ignore next*/var node = path.node;\n        /*istanbul ignore next*/var scope = path.scope;\n\n        var left = node.left;\n\n        if (t.isPattern(left)) {\n          // for ({ length: k } in { abc: 3 });\n\n          var temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [t.variableDeclarator(temp)]);\n\n          path.ensureBlock();\n\n          node.body.body.unshift(t.variableDeclaration(\"var\", [t.variableDeclarator(left, temp)]));\n\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) return;\n\n        var pattern = left.declarations[0].id;\n        if (!t.isPattern(pattern)) return;\n\n        var key = scope.generateUidIdentifier(\"ref\");\n        node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);\n\n        var nodes = [];\n\n        var destructuring = new DestructuringTransformer({\n          kind: left.kind,\n          file: file,\n          scope: scope,\n          nodes: nodes\n        });\n\n        destructuring.init(pattern, key);\n\n        path.ensureBlock();\n\n        var block = node.body;\n        block.body = nodes.concat(block.body);\n      },\n      /*istanbul ignore next*/CatchClause: function CatchClause(_ref6, file) {\n        /*istanbul ignore next*/var node = _ref6.node;\n        /*istanbul ignore next*/var scope = _ref6.scope;\n\n        var pattern = node.param;\n        if (!t.isPattern(pattern)) return;\n\n        var ref = scope.generateUidIdentifier(\"ref\");\n        node.param = ref;\n\n        var nodes = [];\n\n        var destructuring = new DestructuringTransformer({\n          kind: \"let\",\n          file: file,\n          scope: scope,\n          nodes: nodes\n        });\n        destructuring.init(pattern, ref);\n\n        node.body.body = nodes.concat(node.body.body);\n      },\n      /*istanbul ignore next*/AssignmentExpression: function AssignmentExpression(path, file) {\n        /*istanbul ignore next*/var node = path.node;\n        /*istanbul ignore next*/var scope = path.scope;\n\n        if (!t.isPattern(node.left)) return;\n\n        var nodes = [];\n\n        var destructuring = new DestructuringTransformer({\n          operator: node.operator,\n          file: file,\n          scope: scope,\n          nodes: nodes\n        });\n\n        var ref = /*istanbul ignore next*/void 0;\n        if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {\n          ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n          nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]));\n\n          if (t.isArrayExpression(node.right)) {\n            destructuring.arrays[ref.name] = true;\n          }\n        }\n\n        destructuring.init(node.left, ref || node.right);\n\n        if (ref) {\n          nodes.push(t.expressionStatement(ref));\n        }\n\n        path.replaceWithMultiple(nodes);\n      },\n      /*istanbul ignore next*/VariableDeclaration: function VariableDeclaration(path, file) {\n        /*istanbul ignore next*/var node = path.node;\n        /*istanbul ignore next*/var scope = path.scope;\n        /*istanbul ignore next*/var parent = path.parent;\n\n        if (t.isForXStatement(parent)) return;\n        if (!parent || !path.container) return; // i don't know why this is necessary - TODO\n        if (!variableDeclarationHasPattern(node)) return;\n\n        var nodes = [];\n        var declar = /*istanbul ignore next*/void 0;\n\n        for (var i = 0; i < node.declarations.length; i++) {\n          declar = node.declarations[i];\n\n          var patternId = declar.init;\n          var pattern = declar.id;\n\n          var destructuring = new DestructuringTransformer({\n            blockHoist: node._blockHoist,\n            nodes: nodes,\n            scope: scope,\n            kind: node.kind,\n            file: file\n          });\n\n          if (t.isPattern(pattern)) {\n            destructuring.init(pattern, patternId);\n\n            if (+i !== node.declarations.length - 1) {\n              // we aren't the last declarator so let's just make the\n              // last transformed node inherit from us\n              t.inherits(nodes[nodes.length - 1], declar);\n            }\n          } else {\n            nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));\n          }\n        }\n\n        path.replaceWithMultiple(nodes);\n      }\n    }\n  };\n};\n\n/*istanbul ignore next*/\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = exports[\"default\"]; /* eslint max-len: 0 */"]}